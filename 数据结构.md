# 数据结构


---

## 数据结构是一门研究非数值计算的程序设计问题中计算机的操作对象以及他们之间的关系和操作等的学科

----------

### 算法
    有穷性：有穷步之后结束，且每一步都在有穷时间内完成
    确定性：每一条指令必须有确切的含义
    可行性：算法中描述的操作都是可以通过已经实现的基本运算执行有限次来实现的
    输入：有零个或多个输入
    输出：有一个或多个的输出
    
### 线性表

 - **线性表的顺序表示和实现**

      线性表的顺序表示值得是用一组地址连续的存储单元依次存储线性表的数据元素
    线性表的这种机内表示称作线性表的顺序存储结构或顺序映像；以元素在计算机内“物理位置相邻”来表示线性表中数据元素之间的逻辑关系
    
    线性表中任以元素都可随机存取，
    
    - 插入和删除 
    
        - 在第i个位置之前插入元素e
```
q = i-1  //q为插入位置
for(p=length-1;p>q;--p){
*(p+1) = *p;
*q = e；
++length;//表长加1

```        
        
        
        - 删除第i个元素，并用e返回其值
```
        p = L.elem(i-1);
        e = *p;
        q = L.elem+L.length-1;//表尾位置
        for(++p;p<=q;++p)
        *(p-1) = *p;
        --L.length;
```
    
    
#### 注意：C语言中数组的下标从“0”开始，若L是sqList类型的顺序表，则表中第i个数据元素是L.elem[i-1].   


 - **线性表的顺序表示和实现**
    - 线性链表(单链表)
    线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素（这组存储，也可以是不连续的）
    存储逻辑关系：一个数据元素存储本身的信息，还需存储一个指示其直接后继的信息。所以包括两个域：一个数据域，一个指针域
指针域中存储的信息称作指针或链，n个结点链结成一个链表，即为线性表的链式存储结构
    由于此链表的每个结点中只包含一个指针域，故又称线性链表或单链表

    - 指针为数据元素之间的逻辑关系的映像，则逻辑上相邻的两个数据元素其存储的物理位置不要求紧邻，这种存储结构为非顺序映像或链式映像
    在单链表的第一个结点之前附设一个结点，称之为头结点，头结点的数据域可以不存储任何信息，也可以存储如线性表的长度等类的附加信息，
头结点的指针域存储指向第一个结点的指针（即第一个元素结点的存储位置，）假如线性表为空表，则头指针的指针域为“空”

    - 单链表的插入和删除
    
        - 为插入数据元素x，首先要生成一个数据域为x的结点，然后插入在单链表中
        假设s为指向x的指针，
        s->data = e;
        s->next = p->next;
        p->next = s;
        
        - 删除结点
        q= p->next;
        p->next = p->next->next;//p->next = q->next
        e= q->data;
        free(q);
        

        
 1. 循环链表     
    表中最后一个结点的指针域指向头结点，整个链表形成一个环
    循环条件不是p或p->next是否为空，而是判断他们是否等于头指针（或尾指针）。

 2. 双向链表
    有两个指针域，一个指向直接后继，另一个指向直接前驱
                

 3. 双向循环链表
    - 插入和删除
        在第i个位置之前插入元素e
```
    s->data = e;
    s->prior = p-> prior;
    p->prior->next = s;
    s->next = p;
    p->prior = s;
```
    删除第i个元素
```
    e = p->data;
    p->prior->next = p->next;
    p->next->proir = p->proir;
```
    
    
### 栈和队列

 4. 栈
    栈是限定在表尾进行插入和删除操作的线性表，表尾端成为栈顶，表头端成为栈底
    栈是后进先出的线性表


    **栈的两种存储表示方法**：
    
    1：顺序栈：栈的顺序存储结构是利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素，同时附设指针top指示栈顶元素在顺序栈中的位置
    - base可称为栈底指针，在顺序栈中，它始终指向栈底的位置，若base的值为null，则表明栈结构不存在
    - 称top为栈顶指针，其初始值指向栈底，即top=base可作为栈空的标记，
        - 插入新元素，指针top+1；
        - 删除元素，指针top-1；
    因此，非空栈中的栈顶指针始终在栈顶元素的下一个位置上    
    
    2：链式栈：
    栈底为链表的最后一个元素指针域为空
    栈顶为链表的头结点，
    依次由栈顶到栈底用链表的指针链接
    
    
 5. 队列

    - 队列是一种先进先出的线性表
    - 只允许在表的一端（队尾）进行插入，而在另一端（队头）删除元素 
    - 循环队列：用一组地址连续的存储单元依次顺序存放从队列头到队列尾的元素之外，两个指针front和rear分别指示队列头元素和队列尾元素的位置
        - 插入队尾元素时，尾指针增加1，
        - 删除队列头元素时，头指针增1，
        
        
        
### 串
    
    
    串是由零个或多个字符组成的有限序列，用单引号括起来的字符序列是串的值，可以是数字字母或其他字符
    
    
### 广义表
    在广义表的定义中，Ai可以是单个元素，也可以是广义表，分别称为广义表的原子和子表，
    
        - 广义表的存储结构
            采用链式存储结构，每个数据元素可用一个结点表示
            由于列表中的数据元素可能为原子或列表，由此需要两种结构的结点：
            一种是表结点，用以表示列表
                若列表不空，则可分解成表头和表尾，一个表结点可由3个域组成：标志域，指示表头的指针域，指示表尾的指针域
            一种是原子结点，用以表示原子。
                只需两个结点，标志域和值域
                
        
        
###  树和二叉树


----------


    树是n>=0个结点的有限集，在任意一棵非空树中，
        - 有且仅有一个特定的称为根的结点
        - 当n>1时，其余结点可分为m(m>0)个互不相交的有限集，其中每一个集合本身又是一棵树，并且称为根的子树
            
            结点拥有的子树称为结点的度
            度为0的结点称为叶子或中断结点
            度不为0的结点称为非中断结点或分支结点，
            树的度是树内各结点的度的最大值
            同一个双亲的孩子之间互成兄弟
            
            森林是m(m>=0)棵互不相交的树的集合
            
       


----------


     
    - 二叉树
        
        二叉树是n(n>=0)个结点的有限集，它或者是空集（n=0），或者由一个根结点及两棵互不相交的分别称作这个根的左子树和右子树的二叉树组成
        每个结点至多有两棵子树(即二叉树中不存在度大于2的结点)
        
        二叉树的性质
        
            在二叉树的第i层上至多有2的（i-1）幂次方个结点(i>=1)
            深度为k的二叉树的最大结点树为2的k次幂-1
            对任何一棵二叉树t，如果其终端结点数为n，度为2的节点数为m，则n=m+1
    
----------


        
        完全二叉树和满二叉树是两种特殊形态的二叉树
        一棵深度为k且有2的k次幂-1个结点的二叉树称为满二叉树
        对任一结点，若其右分支下的子孙的最大层次为a，则其左分支下的子孙的最大层次必为a或a+1
        
        
 遍历二叉树和线索二叉树
 
    先序遍历二叉树的操作定义：
        1.访问根结点
        2.先序遍历左子树
        3.先序遍历右子树
    中序遍历二叉树的操作定义：
        1.遍历左子树
        2.访问根结点
        3.中序遍历右子树
    后序遍历二叉树的操作定义：
        1.后序遍历左子树
        2.后序遍历右子树
        3.访问根结点
        
    赫夫曼树及其应用
        又称最优树，是一类带权路径长度最短的树
        
        从树中一个结点到另一个结点之间的分支构成两个结点之间的路径，
        路径上的分支数目称作路径长度
        树的路径长度是从树根到每一个结点的路径长度之和
        
        树的带权路径长度为树中所有叶子结点的带权路径长度之和
        
        构造过程：
        选择两小创新树
        1，在集合中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为左右子树结点的权值之和      
        2，在集合中删除这两棵树，同时将新的二叉树加入集合中
        3，重复，直到集合之含一棵树为止。
        
        
### 图 


    1. 在图中的数据元素通常称作顶点，v是顶点的有穷非空集合，vr是两个顶点之间的关系的集合
    
    - 图可以分为有向图和无向图，在图中：
        若<u,v>属于vr，则<u,v>表示从u到v的一条弧，且称u为弧尾或者初始点，称v为弧头或终端点，此时的图称为有向图
        若（u，v）是互通的，则（u，v）表示无向边
    
    2. 图可以分为有权图和无权图：
        - 有权图：每条边具有一定的权重，通常是一个数字
        -权：图的边或弧具有与他相关的数，权可以表示从一个顶点到另一个顶点的距离或耗费。
    3.度的概念
        - 度：所有与他连接点的个数之和
        -入度：存在于有向图中，所有接入该店的边数之和
        -出度：存在于有向图中，所有接触该点的边数之和
        
    4.图的存储结构
        邻接表：
            - 对于每个顶点建立一个单链表，
            - 对于有权图来说，链表中元素对应着权重
        牺牲很大的时间来查找，因此比较耗时，而邻接矩阵法相比邻接链表法来说，时间复杂度低。
        
        
    最小生成树
        一棵生成树的代价就是树上各边的代价之和。
        - 普利姆算法
            1.找出最权值小的一条边<u,v>，为生成树的第一条边，同时将顶点放入集合中，
            2.由集合中的两点出发，再找权值最小的边，并把新的顶点放入集合中
            3.重复，直到所有顶点都在集合中
            时间复杂度：O(V^2)
        - 克鲁斯卡尔算法
            1.依次选择代价最小的边，将顶点连通，构造出最小生成树        
            时间复杂度：O(ElogV)
            
        拓扑排序
            1.在有向图中选一个没有前驱的顶点且输出之
            2.从图中删除该顶点和所有以它为尾的弧
            重复上述步骤
        
        关键路径
            路径长度最长的路径叫做关键路径
            分析关键路径的目的是辨别那些是关键活动，以便争取提高关键活动的功效
            从源点出发，求其余各顶点的最早发生时间，
            从汇点出发，求各顶点的最迟发生时间
            
        最短路径
[dijkstra算法](https://blog.csdn.net/ak_lady/article/details/70169515)
            