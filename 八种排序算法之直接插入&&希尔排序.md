#八种排序算法



----------
##直接插入排序(Straight Insertion Sorting) 

----------
> 基本思想：在要排序的一组数中，假设前面(n-1)[n>=2]个数已经是排好顺序的，现在要把第n个数插到前面的有序数中，使得这n个也是排好顺序的，如此反复循环，直到全部排好顺序。

![排序步骤变化](https://raw.githubusercontent.com/CharonChui/Pictures/master/straight_insertion_sorting.png)

####总体分析：

> * 用第二个数和第一个数比较大小，大的放到右边
* 用第三个数分别和第二个数还有第一个数比较，并把大的放到右边
* 用第四个数分别和第一个第三个第二个第一个数比较，并把大的放到右边。
* ....

所以这里肯定要用到嵌套for循环。

```java
   public void insertSort(int[] arr){
    int len = arr.length;
    //要插入的数
    int insertNum;
    //因为第一次不用，所以从1开始
    for(int i = 1;i<len;i++){
        int sertNum = arr[i];
        //序列元素个数
        int j = i-1;
        //从后往前循环，将大于insertNum的数向后移动
        while(j>0&&arr[j]>insertNum){
            //元素向后移动
            arr[j + 1] = arr[j];
            j--;
        }
        //找到位置，插入当前元素
        arr[j + 1] = insertNum;
    }
   }
```
---

##希尔排序
> 希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本，希尔排序是非稳定排序算法。
希尔排序的z实质就是分组插入排序，该方法又是称缩小增量排序

#### 基本思想：先将整个待排序元素序列分割成若干个子序列（由相隔的某个“增量”的元素组成的），分别进行直接插入排序，然后依次缩减增量再进入排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。因为直接插入排序在元素基本有序的情况下（接近最好情况），效率是很高的，因此希尔排序在时间效率上比前两种方法有较大提高，步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。

**希尔排序是基于插入排序的以下两点性质而提出改进方法的：**

* 插入排序在对几乎已经排好的数据操作时，效率高，即可以达到线性排序的效率
* 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位


对于直接插入排序问题，数据量巨大时。将数的个数设为n，取奇数k=n/2，将下标差值为k的数分为一组，构成有序序列。再取k=k/2，将下标差值为k的书分为一组，构成有序序列。重复第二步，直到k=1执行简单插入排序。


算法最开始以一定的步长进行排序,然后会继续以一定步长进行排序，最终算法以步长为1进行排序。当步长为1时，算法变为插入排序，这就保证了数据一定会被排序。 DonaldShell最初建议步长选择为\frac{n}{2}并且对步长取半直到步长达到1。虽然这样取可以比\mathcal{O}(n^2)类的算法（插入排序）更好，但这样仍然有减少平均时间和最差时间的余地。


>  希尔排序示例：n = 10 的的一个数组 58 27 32 93 65 87 58 46 9 65，步长为n/2。
第一次排序 步长为 10/2 = 5
　　　　58　27　32　93　65　87　58　46　9　65 
　　　　1A　　　　　　　　　1B
　　　　　　2A　　　　　　　　　2B
　　　　　　　　3A　　　　　　　　　3B
　　　　　　　　　　4A　　　　　　　　　4B
　　　　　　　　　　　　5A　　　　　　　　　5B
　　　　　　　　　　　　
首先将待排序元素序列分组，以5为步长，(1A,1B),(2A,2B),(3A,3B)等为分组标记，大写字母表示是该组的第几个元素,
数字相同的表示在同一组，这样就分成5组，即(58,87),(27,58),(32,46),(93,9),(65,65)，
然后分别对各分组进行直接插入排序，排序后5组为(58,87),(27,58),(32,46),(9,93),(65,65)，
分组排序只是变得各个分组内的下表，下同。
第二次排序 步长为 5/2 = 2
58　27　32　9　65　87　58　46　93　65
1A　　　1B　　　1C　　　1D　　　1E

　　　　2A　　2B　　　2C　　　2D　　　2E
第三次排序 步长为 2/2 = 1

32　9　58　27　58　46　65　65　93　87

1A　1B　1C　1D　1E　1F　1G　1H　1I 　1J

第四次排序 步长为 1/2 = 0 得到有序元素序列

9　27　32　46　58　58　65　65　87　93

```java
   public void shellSort(int[] arr){
    int len = arr.length;
    while(len != 0){
        len = len/2;
        //分组
        for(int i =0;i<len;i++){
            //从元素从第二个开始
            for(int j = i+len;j<arr.length;j+=len){
                //k为有序序列最后一位的位数
                int k = j - len;
                //要插入的元素
                int temp = arr[j];
                //从后往前遍历
                while (k >= 0 && temp < arr[k]) {
                    arr[k + len] = arr[k];
                    //向后移动len位
                    k -= len;
                }
                arr[k + len] = temp;
            }
        }
    }
   }
```



    
 
